#!/usr/bin/ruby

require 'xml/libxml'
require 'rubytui'
include RubyTUI

builder = prompt('Who built the box?')
qcer = prompt('Who is QCing the box?')
message('Please ensure the printer is connected and press enter')
waitasec

filename = '/tmp/lshw.xml'

`lshw -xml>#{filename}`

doc = XML::Document.file(filename)

def to_megabytes(num)
    num.to_i / 1024 / 1024
end

def format_megabytes(num)
    '%d megabytes' % to_megabytes(num)
end

classes = {
    'processor'=> nil,
    'communication'=> nil, 
    'network'=> {'product' => '%s', 'vendor' => '%s'},
    'memory'=> {'size' => method('format_megabytes')},
    'display'=> {'product' => '%s', 'vendor' => '%s', 'size' => method('format_megabytes')}, 
    'multimedia'=> nil, 
    'disk' => {'vendor' => '%s','capacity' => method('format_megabytes')}
}

ordered = %w[processor disk memory network display multimedia communication]

printable = <<EOF
Built by: %s
QCed by: %s

EOF

printable %= [builder, qcer]

ordered.each {|c|
    if c == 'memory'
        xpath = 'descendant::*[attribute::id="%s"]' % c
    else
        xpath = 'descendant::*[attribute::class="%s"]' % c
    end
    subnodes = classes[c] || {'product' => '%s'}
    nodes = doc.root.find(xpath)
    nodes.class.class_eval {include Enumerable}
    printable += "#{c}: \n    " 
    printable += nodes.map {|n|
        subnodes.map {|sub,format|
            n.find('child::%s' % sub).map {|prod| 
                if prod.content and ! prod.content.empty?
                    prod = prod.content
                end
                if format.respond_to?('call')
                    format.call(prod.to_s)
                else
                    format % prod.to_s
                end
            }.join("\n    ")
        }.join("\n    ")
    }.join("\n\n    ")
    printable += "\n\n"
}

puts printable
exit

f = open('|lpr','w')
f.write(printable)
f.close()

message 'go pick up your paper'
