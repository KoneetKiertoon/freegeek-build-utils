#!/usr/bin/ruby

require 'yaml'
f = File.open('/etc/printme.yml')
yaml = YAML.load(f.read)
f.close
keys = ['server', 'port']
if !(yaml.keys - keys == [] && keys - yaml.keys == [])
  puts "Invalid configuration file"
  exit 1
end
$server = yaml['server'] + ':' + yaml['port'].to_s

#configuration
# $server="printme:80"

$COLOR = true #make things cool
$PRINTME_VERSION=9

require 'rubytui'
require 'fileutils'
require 'soap/rpc/driver'
include FileUtils
include RubyTUI

trap( "SIGINT" ) {
  `reset -Q`
  errorMessage "\n\nUser interrupt caught.  Exiting.\n\n"
  exit!( 1 )
}

def runit(lshwname)
  return if $debug
  if File.exist?(lshwname)
    mv(lshwname, lshwname + '.old')
  end
  system("sudo lshw -xml>#{lshwname}")
end

def run_lshw_and_test_stuff
  lshwname = '/var/lib/freegeek-extras/printme/lshw.xml'
  runit(lshwname)
  lshw = File.open(lshwname, "rb")
  @lshw_output = lshw.read
  lshw.close
end

def get_id_and_stuff
  if ! File.exist?('/var/lib/freegeek-extras/')
    system 'sudo mkdir /var/lib/freegeek-extras/'
  end
  system "sudo chown -R #{ENV['USER']}:#{ENV['USER']} /var/lib/freegeek-extras/"
  if ! File.exist?('/var/lib/freegeek-extras/printme')
    mkdir('/var/lib/freegeek-extras/printme/')
  end

  if File.exist?('/var/lib/freegeek-extras/printme/system_id')
    @old_system_id ||= File.read('/var/lib/freegeek-extras/printme/system_id').strip.to_i
  elsif File.exist?('/var/lib/freegeek-extras/printme/system.xml') # old new printme has been ran
    require 'rexml/document'
    @old_system_id ||= REXML::XPath.match(REXML::Document.new(File.read("/var/lib/freegeek-extras/printme/system.xml")), '/system/id').first.get_text.to_s.to_i
  end

  @actions = @driver.actions
  @contracts = @driver.contracts
  @types = @driver.types

  @old_system_id ||= prompt('If the system had an id on it already, enter that here',
                        'Please supply a number or nothing at all') {|num| num.empty? or (num.to_i.to_s == num)}
end

def get_current_info
  @detected_system_id = @driver.get_system_id(@lshw_output)
  if @detected_system_id
    @default_contract = @driver.contract_label_for_system(@detected_system_id)
  else
    @default_contract = @driver.default_contract_label
  end
  if @detected_system_id
    @default_type = @driver.type_description_for_system(@detected_system_id)
  else
    @default_type = @driver.default_type_description
  end
  @default_action = @driver.default_action_description
end

def show_message
  puts
  puts colored("You are are changing the contract.", 'bold', 'green')
  out = prompt "Are you sure that you entered it correctly (HINT: look at the sticker)?", "Please type yes or no" do |x|
    x.match(/yes/i) || x.match(/no/i)
  end
  return out.match(/yes/i)
end

class Array
  def to_my_array(thing)
    arr = []
    self.each{|x|
      arr[x.thing_id] = eval("x.#{thing}")
    }
    arr
  end
end

def ask_and_send_stuff
  action = numberedMenuWithDefault('Work Tasks', 'Which job did you perform?', @default_action, @actions.to_my_array("description"))
  type = numberedMenuWithDefault('System Type', 'What kind of system is this intended to be?', @default_type, @types.to_my_array("description"))
  first_time = @detected_system_id.nil?
  contract = nil
  loop do
    contract = numberedMenu('Contract Type', "What does the \"keeper\" label say? [#{@default_contract}]", @contracts.to_my_array("label"))
    if contract != @default_contract && !first_time
      if show_message
        break
      end
    else
      break
    end
  end
  uid = prompt('What is your volunteer id?', 'Please enter a number.') {|num| num.to_i.to_s == num}
  notes = prompt('What, if anything, is notable about this system?')

  codename = `lsb_release --description --short`

  data = {
    "contact_id" => uid,
    "action_id" => @actions.select{|x| x.description == action}.first.thing_id,
    "type_id" => @types.select{|x| x.description == type}.first.thing_id,
    "contract_id" => @contracts.select{|x| x.label == contract}.first.thing_id,
    "old_id" => @old_system_id,
    "notes" => notes,
    "lshw_output" => @lshw_output,
    "os" => codename
  }

  data_struct = @driver.empty_struct
  data.each{|k,v|
    eval("data_struct.#{k} = v")
  }

  @report_id = @driver.submit(data_struct)
  system_id=@driver.get_system_for_report(@report_id)
  if system_id != @old_system_id
    @old_system_id = system_id
  end

  system=File.open('/var/lib/freegeek-extras/printme/system_id', 'w')
  system.puts(@old_system_id)
  system.close
  Dir.glob("/var/lib/freegeek-extras/printme/{system,report.*,spec_sheet.*}.xml").each{|x| rm x} # remove teh cruft
end

def client_hash
  client_versions = Hash.new([])
  client_versions[1] = [1]      # dunno
  client_versions[2] = [2,3]    # first one that makes it here. forced upgrade.
  client_versions[3] = [3]      # forced upgrade
  client_versions[4] = [3,4]    # forced upgrade
  client_versions[5] = [5]      # forced. the server needs to clean the xml now since printme isn't.
  client_versions[6] = [6,7]      # forced. add contracts support.
  client_versions[7] = [6,7,8]      # forced. fix contracts support. (bad builder problem)
  client_versions[8] = [6,7,8]      # forced. fix contracts support. (my bugs)
  client_versions[9] = [9] # soap
  client_versions
end

def check_version
  begin
    retval = @driver.ping
    if retval != "pong"
      errorMessage "I could not connect to the server.\nMake sure you are connected to the network and try again.\n\n"
      exit false
    end
  rescue SOAP::RPCRoutingError, SOAP::ResponseFormatError, Errno::ECONNREFUSED, Errno::EHOSTUNREACH, Errno::ENETDOWN, Errno::ENETUNREACH, Errno::ECONNRESET, Errno::ETIMEDOUT, NoMethodError, NameError => e
    errorMessage "I could not connect to the server (#{e.message}).\nMake sure you are connected to the network and try again.\n\n"
    exit false
  end
  if !@driver.version_compat($PRINTME_VERSION)
    errorMessage @driver.bad_client_error
    exit false
  end
  if !client_hash[$PRINTME_VERSION].include?(@driver.version)
    errorMessage @driver.bad_server_error
    exit false
  end
end

def printer_there?(printer)
  `lpstat -p`.split("\n").map{|x| x.split(" ")[1]}.include?(printer)
end

def printer_setup
  printer = ARGV[1]
  system('sudo su - -c "echo \"Browsing Yes #freegeek-extras\" >> /etc/cups/cupsd.conf"')
  if File.exists?("/etc/init.d/cups")
    system('sudo /etc/init.d/cups restart >/dev/null')
  elsif File.exists?("/etc/init.d/cupsys")
    system('sudo /etc/init.d/cupsys restart >/dev/null')
  else
    errorMessage "ERROR: Can't figure out how to restart cups\n\n"
    exit 1
  end
  num = 0
  found=false
  if printer.nil? || printer.empty?
    errorMessage "the #{ARGV[0]} option required an option (the printer's name)" + "\n"
    exit 1
  end
  # in my tests it took about 27 seconds for cups to figure it out
  while num < 10
    num += 1
    printf "looking for printer #{printer}..."
    if printer_there?(printer)
      found=true
      puts "found it"
      break
    else
      found=false
      printf "not found "
      if num < 10
        sleep 5
        puts "(will try again in a few seconds)"
      else
        puts "(giving up)"
      end
    end
  end
  puts
  if !found
    errorMessage "Please specify a valid printer." + "\n\n"
    exit 1
  end
  system("sudo su - -c \"echo \\\"Default #{printer} #freegeek-extras\\\" >> /etc/cups/lpoptions\"")
end

def add_method(*args)
  @driver.add_method(*args)
end

  def add_methods
    # Connection Testing
    add_method("ping")
    # Version Checking
    add_method("version_compat", "client_version")
    add_method("version")
    add_method("bad_client_error")
    add_method("bad_server_error")
    # Lists
    add_method("actions")
    add_method("types")
    add_method("contracts")
    add_method("default_action_description")
    add_method("default_type_description")
    add_method("default_contract_label")
    # Printme
    add_method("empty_struct")
    add_method("submit", "printme_struct")
    # Random Crap
    add_method("get_system_for_report", "report_id")
    add_method("contract_label_for_system", "system_id")
    add_method("type_description_for_system", "system_id")
    add_method("spec_sheet_url", "report_id")
    add_method("get_system_id", "xml")
  end

def setup_soap
  @driver = SOAP::RPC::Driver.new("http://#{$server}/", "urn:printme")
  add_methods # copy from the api
end

def color(blah)
  puts colored(blah) if $debug
end

def main
  check_for_people_who_dont_read_the_instructions
  if ARGV[0] == "-p" || ARGV[0] == "--printer"
    printer_setup
  end
  if ARGV[0] == "-h" || ARGV[0] == "--help"
    system("man 1 printme | cat -")
    exit 0
  end
  begin
    color "Setting up connection to the server..."
    setup_soap
    check_version
    color "Running lshw..."
    run_lshw_and_test_stuff
    color "Getting information about this system's past..."
    get_current_info
    color "Asking questions and submitting to server..."
    get_id_and_stuff
    ask_and_send_stuff
  rescue SOAP::FaultError => e
    errorMessage "Server returned this error: #{e.message}\n\n"
    exit 1
  rescue NoMethodError, NameError
    errorMessage "There's a BUG in printme!\n\n"
    exit 1
  end
  url="http://#{$server}#{@driver.spec_sheet_url(@report_id)}"
  if ! system "firefox #{url}"
    puts url
  end
end

def check_for_people_who_dont_read_the_instructions
  if ENV['USER'] == "root"
    puts "DO NOT RUN PRINTME AS ROOT. if you are typing 'sudo printme', then that is incorrect. Just type 'printme'."
    exit 1
  end
end

main
