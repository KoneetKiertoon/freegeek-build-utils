#!/usr/bin/ruby

require 'yaml'
f = File.open('/etc/printme.yml')
yaml = YAML.load(f.read)
f.close
keys = ['server', 'port']
if !(yaml.keys - keys == [] && keys - yaml.keys == [])
  puts "Invalid configuration file"
  exit 1
end
$server = yaml['server'] + ':' + yaml['port'].to_s

#configuration
# $server="printme:80"

#make this singular
$reports_controller = "spec_sheet"
$types_model = "type"
$jobs_model = "action"
$contracts_model = "contract"

$COLOR = true #make things cool
$PRINTME_VERSION=9

begin
  require 'xmlsimple'     # installed by freegeek-xmlsimple, and where the real package installs it now
rescue LoadError
  require 'lib/xmlsimple' # installed by old debian package, http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=491730
end
require 'net/http'
require 'cgi'
require 'uri'
require 'rubytui'
require 'fileutils'
require 'soap/rpc/driver'
include FileUtils
include RubyTUI

trap( "SIGINT" ) {
  `reset -Q`
  errorMessage "\n\nUser interrupt caught.  Exiting.\n\n"
  exit!( 1 )
}

module Multipart
  # From: http://kfahlgren.com/code/multipart.rb
  class Param
    attr_accessor :k, :v
    def initialize( k, v )
      @k = k
      @v = v
    end

    def to_multipart
      return "Content-Disposition: form-data; name=\"#{CGI::escape k}\"\r\n\r\n#{v}\r\n"
    end
  end
  class FileParam
    attr_accessor :k, :filename, :content
    def initialize( k, filename, content )
      @k = k
      @filename = filename
      @content = content
    end

    def to_multipart
      # Don't escape mine
      return "Content-Disposition: form-data; name=\"#{k}\"; filename=\"#{filename}\"\r\n" + "Content-Transfer-Encoding: binary\r\n" + "Content-Type: application/xml\r\n\r\n" + content + "\r\n"
    end
  end
  class MultipartPost
    BOUNDARY = 'tarsiers-rule0000'
    HEADER = {"Content-type" => "multipart/form-data, boundary=" + BOUNDARY + " ", "User-Agent"=>"printme v" + $PRINTME_VERSION.to_s}

    def prepare_query (params)
      fp = []
      params.each {|k,v|
        if v.respond_to?(:read)
          fp.push(FileParam.new(k, v.path, v.read))
        else
          fp.push(Param.new(k,v))
        end
      }
      query = fp.collect {|p| "--" + BOUNDARY + "\r\n" + p.to_multipart }.join("") + "--" + BOUNDARY + "--"
      return query, HEADER
    end
  end
end

def fetch(url, limit = 10)
  return nil if limit == 0

  response = Net::HTTP.get_response(URI.parse(url))
  case response
  when Net::HTTPSuccess
    response
  when Net::HTTPRedirection
    fetch(response['location'], limit - 1)
  else
    nil
  end
end

TIMEOUT_SECONDS = 30
def post_form(url, query, headers)
  limit=10
  Net::HTTP.start(url.host, url.port) { |con|
    con.read_timeout = TIMEOUT_SECONDS
    begin
      response = con.post(url.path, query, headers)
      case response
      when Net::HTTPSuccess
        return response
      when Net::HTTPRedirection
        return fetch(response['location'], limit - 1)
      else
        nil
      end
    rescue => e
      nil
    end
  }
end

def run_lshw_and_test_stuff
  if File.exist?("/var/lib/freegeek-extras/printme/lshw.xml")
    mv('/var/lib/freegeek-extras/printme/lshw.xml', '/var/lib/freegeek-extras/printme/lshw.xml.old')
  end
  $lshwname = '/var/lib/freegeek-extras/printme/lshw.xml'
  system("sudo lshw -xml>#{$lshwname}")
end

def get_id_and_stuff
  if ! File.exist?('/var/lib/freegeek-extras/')
    system 'sudo mkdir /var/lib/freegeek-extras/'
  end
  system "sudo chown -R #{ENV['USER']}:#{ENV['USER']} /var/lib/freegeek-extras/"
  if ! File.exist?('/var/lib/freegeek-extras/printme')
    mkdir('/var/lib/freegeek-extras/printme/')
  end

  if File.exist?('/var/lib/freegeek-extras/printme/system_id')
    @system_id ||= File.read('/var/lib/freegeek-extras/printme/system_id').strip.to_i
  elsif File.exist?('/var/lib/freegeek-extras/printme/system.xml') # old new printme has been ran
    system = File.open('/var/lib/freegeek-extras/printme/system.xml', 'r')
    @system_id ||= XmlSimple.xml_in(system)["id"][0]["content"]
  end

  actions = @driver.actions
  contracts = @driver.contracts
  types = @driver.types

  @jobs={}
  @types={}
  @contracts={}

  @jobs_by_name={}
  @types_by_name={}
  @contracts_by_name={}

  @jobs_arr = []
  @types_arr = []
  @contracts_arr=[]

  actions.each{|x|
    @jobs[x.description] = x.thing_id
    @jobs_by_name[x.name] = x.description
    @jobs_arr[x.thing_id] = x.description
  }

  types.each{|x|
    @types[x.description] = x.thing_id
    @types_by_name[x.name] = x.description
    @types_arr[x.thing_id] = x.description
  }

  contracts.each{|x|
    @contracts[x.label] = x.thing_id
    @contracts_by_name[x.name] = x.label
    @contracts_arr[x.thing_id] = x.label
  }

  @system_id ||= prompt('If the system had an id on it already, enter that here',
                        'Please supply a number or nothing at all') {|num| num.empty? or (num.to_i.to_s == num)}
  system.close if system
end

#these two are stolen and modified from rubytui

def my__displayMenu( head, ques, *m_items )
  header head
  m_items.each_with_index {|item, i|
    if !item.nil?
      highlight "\t%d" % i.to_s
      display ": %s\n" % item
    end
  }
  choice = prompt( ques )
  return choice.empty? ? nil : choice.to_i
end

def my_menuWithDefault( head, ques, default, is_evil, *m_items )
  if (m_items - [default, nil]).length == 0
    return default
  end
  choice = my__displayMenu( head, ques + " [#{default}]", *m_items )
  return default unless choice or is_evil
  valid_choices = []
  m_items.each_with_index{|x,i|
    valid_choices << i if !x.nil?
  }
  until valid_choices.include?( choice )
    errorMessage "\nPlease enter a valid choice\n\n"
    choice = my__displayMenu( head, ques + " [#{default}]", *m_items )
    return default unless choice or is_evil
  end
  return m_items[choice]
end

def show_message
  puts
  puts colored("You are are changing the contract.", 'bold', 'green')
  out = prompt "Are you sure that you entered it correctly (HINT: look at the sticker)?", "Please type yes or no" do |x|
    x.match(/yes/i) || x.match(/no/i)
  end
  return out.match(/yes/i)
end

def ask_and_send_stuff
  #TODO: choose the default type based on the last report. this isn't saved on the systems table, so it's gonna be a bit messy.
  job = my_menuWithDefault('Work Tasks', 'Which job did you perform?', @jobs_by_name["checker"], false, *@jobs_arr)
  type = my_menuWithDefault('System Type', 'What kind of system is this intended to be?', @types_by_name['regular'], false, *@types_arr)
  default = nil
  if File.exists?("/var/lib/freegeek-extras/printme/system.xml")
    xml = XmlSimple.xml_in(File.read("/var/lib/freegeek-extras/printme/system.xml"))
    default = @contracts_arr[xml["contract-id"][0]["content"].to_i] if xml["contract-id"]
  end
  first_time = default.nil? or default.empty?
  default = @contracts_by_name['default'] if first_time
  contract = nil
  loop do
    contract = my_menuWithDefault('Contract Type', "What does the \"keeper\" label say?", default, true, *@contracts_arr)
    if contract != default && !first_time
      if show_message
        break
      end
    else
      break
    end
  end
  uid = prompt('What is your volunteer id?', 'Please enter a number.') {|num| num.to_i.to_s == num}
  notes = prompt('What, if anything, is notable about this system?')

  lshw = File.open($lshwname, "rb")
  codename = `lsb_release --description --short`

  data = {
    "contact_id" => uid,
    "action_id" => @jobs[job],
    "type_id" => @types[type],
    "contract_id" => @contracts[contract],
    "old_id" => @system_id,
    "notes" => notes,
    "lshw_output" => lshw.read,
    "os" => codename
  }

  lshw.close

  data_struct = @driver.empty_struct
  data.each{|k,v|
    eval("data_struct.#{k} = v")
  }

  puts @driver.submit(data_struct)
  exit 0

  mp = Multipart::MultipartPost.new
  query, headers = mp.prepare_query(data)

  response = post_form(uri, query, headers)
  if response == nil
    errorMessage "Problem posting to the server\n\n"
    exit 1
  end
  response_xml = XmlSimple.xml_in(response.body)
  if response_xml["error"]
    errorMessage "The server return this error: " + response_xml["error"][0] + "\n\n"
    exit 1
  end
  @report_id=response_xml["id"][0]["content"]
  system_id=response_xml["system-id"][0]["content"]
  if system_id != @system_id
    @system_id = system_id
  end

  system=File.open('/var/lib/freegeek-extras/printme/system_id', 'w')
  system.puts(@system_id)
  system.close
end

class String
  def to_bool
    return true if self == "true"
    return false if self.nil? || self == "false"
    return nil
  end
end

def client_hash
  client_versions = Hash.new([])
  client_versions[1] = [1]      # dunno
  client_versions[2] = [2,3]    # first one that makes it here. forced upgrade.
  client_versions[3] = [3]      # forced upgrade
  client_versions[4] = [3,4]    # forced upgrade
  client_versions[5] = [5]      # forced. the server needs to clean the xml now since printme isn't.
  client_versions[6] = [6,7]      # forced. add contracts support.
  client_versions[7] = [6,7,8]      # forced. fix contracts support. (bad builder problem)
  client_versions[8] = [6,7,8]      # forced. fix contracts support. (my bugs)
  client_versions[9] = [9] # soap
  client_versions
end

def check_version
  begin
    retval = @driver.ping
    if retval != "pong"
      errorMessage "I could not connect to the server.\nMake sure you are connected to the network and try again.\n\n"
      exit false
    end
  rescue SOAP::RPCRoutingError, SOAP::ResponseFormatError, Errno::ECONNREFUSED, Errno::EHOSTUNREACH, Errno::ENETDOWN, Errno::ENETUNREACH, Errno::ECONNRESET, Errno::ETIMEDOUT, NoMethodError, NameError => e
    errorMessage "I could not connect to the server (#{e.message}).\nMake sure you are connected to the network and try again.\n\n"
    exit false
  end
  if !@driver.version_compat($PRINTME_VERSION)
    errorMessage @driver.bad_client_error
    exit false
  end
  if !client_hash[$PRINTME_VERSION].include?(@driver.version)
    errorMessage @driver.bad_server_error
    exit false
  end
end

def printer_there?(printer)
  `lpstat -p`.split("\n").map{|x| x.split(" ")[1]}.include?(printer)
end

def printer_setup
  printer = ARGV[1]
  system('sudo su - -c "echo \"Browsing Yes #freegeek-extras\" >> /etc/cups/cupsd.conf"')
  if File.exists?("/etc/init.d/cups")
    system('sudo /etc/init.d/cups restart >/dev/null')
  elsif File.exists?("/etc/init.d/cupsys")
    system('sudo /etc/init.d/cupsys restart >/dev/null')
  else
    errorMessage "ERROR: Can't figure out how to restart cups\n\n"
    exit 1
  end
  num = 0
  found=false
  if printer.nil? || printer.empty?
    errorMessage "the #{ARGV[0]} option required an option (the printer's name)" + "\n"
    exit 1
  end
  # in my tests it took about 27 seconds for cups to figure it out
  while num < 10
    num += 1
    printf "looking for printer #{printer}..."
    if printer_there?(printer)
      found=true
      puts "found it"
      break
    else
      found=false
      printf "not found "
      if num < 10
        sleep 5
        puts "(will try again in a few seconds)"
      else
        puts "(giving up)"
      end
    end
  end
  puts
  if !found
    errorMessage "Please specify a valid printer." + "\n\n"
    exit 1
  end
  system("sudo su - -c \"echo \\\"Default #{printer} #freegeek-extras\\\" >> /etc/cups/lpoptions\"")
end

def add_method(*args)
  @driver.add_method(*args)
end

  def add_methods
    # Connection Testing
    add_method("ping")
    # Version Checking
    add_method("version_compat", "client_version")
    add_method("version")
    add_method("bad_client_error")
    add_method("bad_server_error")
    # Lists
    add_method("actions")
    add_method("types")
    add_method("contracts")
    # Printme
    add_method("empty_struct")
    add_method("submit", "printme_struct")
    add_method("get_system_for_report", "report_id")
    add_method("contract_id_for_system", "system_id")
  end

def setup_soap
  @driver = SOAP::RPC::Driver.new("http://#{$server}/", "urn:printme")
  add_methods # copy from the api
end

def main
  check_for_people_who_dont_read_the_instructions
  if ARGV[0] == "-p" || ARGV[0] == "--printer"
    printer_setup
  end
  if ARGV[0] == "-h" || ARGV[0] == "--help"
    system("man 1 printme | cat -")
    exit 0
  end
  begin
    setup_soap
    check_version
    get_id_and_stuff
    run_lshw_and_test_stuff
    ask_and_send_stuff
  rescue SOAP::FaultError => e
    errorMessage "Server returned this error: #{e.message}\n\n"
    exit 1
  rescue NoMethodError, NameError
    errorMessage "There's a BUG in printme!\n\n"
    exit 1
  end
  url="http://#{$server}/#{$reports_controller}s/show/#{@report_id}"
  if ! system "firefox #{url}"
    puts url
  end
end

def check_for_people_who_dont_read_the_instructions
  if ENV['USER'] == "root"
    puts "DO NOT RUN PRINTME AS ROOT. if you are typing 'sudo printme', then that is incorrect. Just type 'printme'."
    exit 1
  end
end

main
