#!/usr/bin/ruby

require 'yaml'
f = File.open('/etc/printme.yml')
yaml = YAML.load(f.read)
f.close
keys = ['server', 'port']
if !(yaml.keys - keys == [] && keys - yaml.keys == [])
  puts "Invalid configuration file"
  exit 1
end
$server = yaml['server'] + ':' + yaml['port'].to_s

#configuration
# $server="printme:80"

#make this singular
$reports_controller = "spec_sheet"
$types_model = "type"
$jobs_model = "action"

$COLOR = true #make things cool
$PRINTME_VERSION=5

begin
  require 'lib/xmlsimple' # installed by debian package, http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=491730
                          # I'd assume that's where ubuntu puts it too
                          # Though I have no clue because packages.ubuntu.com has been timeing out for the last day
rescue LoadError
  require 'xmlsimple'     # installed by freegeek-xmlsimple, and someday where the real package will install it
end
require 'net/http'
require 'cgi'
require 'uri'
require 'rubytui'
require 'fileutils'
include FileUtils
include RubyTUI

trap( "SIGINT" ) {
  `reset -Q`
  errorMessage "\n\nUser interrupt caught.  Exiting.\n\n"
  exit!( 1 )
}

module Multipart
  # From: http://kfahlgren.com/code/multipart.rb
  class Param
    attr_accessor :k, :v
    def initialize( k, v )
      @k = k
      @v = v
    end

    def to_multipart
      return "Content-Disposition: form-data; name=\"#{CGI::escape k}\"\r\n\r\n#{v}\r\n"
    end
  end
  class FileParam
    attr_accessor :k, :filename, :content
    def initialize( k, filename, content )
      @k = k
      @filename = filename
      @content = content
    end

    def to_multipart
      # Don't escape mine
      return "Content-Disposition: form-data; name=\"#{k}\"; filename=\"#{filename}\"\r\n" + "Content-Transfer-Encoding: binary\r\n" + "Content-Type: application/xml\r\n\r\n" + content + "\r\n"
    end
  end
  class MultipartPost
    BOUNDARY = 'tarsiers-rule0000'
    HEADER = {"Content-type" => "multipart/form-data, boundary=" + BOUNDARY + " ", "User-Agent"=>"printme v" + $PRINTME_VERSION.to_s}

    def prepare_query (params)
      fp = []
      params.each {|k,v|
        if v.respond_to?(:read)
          fp.push(FileParam.new(k, v.path, v.read))
        else
          fp.push(Param.new(k,v))
        end
      }
      query = fp.collect {|p| "--" + BOUNDARY + "\r\n" + p.to_multipart }.join("") + "--" + BOUNDARY + "--"
      return query, HEADER
    end
  end
end

def fetch(url, limit = 10)
  return nil if limit == 0

  response = Net::HTTP.get_response(URI.parse(url))
  case response
  when Net::HTTPSuccess
    response
  when Net::HTTPRedirection
    fetch(response['location'], limit - 1)
  else
    nil
  end
end

TIMEOUT_SECONDS = 30
def post_form(url, query, headers)
  limit=10
  Net::HTTP.start(url.host, url.port) { |con|
    con.read_timeout = TIMEOUT_SECONDS
    begin
      response = con.post(url.path, query, headers)
      case response
      when Net::HTTPSuccess
        return response
      when Net::HTTPRedirection
        return fetch(response['location'], limit - 1)
      else
        nil
      end
    rescue => e
      nil
    end
  }
end

def run_lshw_and_test_stuff
  if File.exist?("/var/lib/freegeek-extras/printme/lshw.xml")
    mv('/var/lib/freegeek-extras/printme/lshw.xml', '/var/lib/freegeek-extras/printme/lshw.xml.old')
  end
  $lshwname = '/var/lib/freegeek-extras/printme/lshw.xml'
  system("sudo lshw -xml>#{$lshwname}")
end

def do_setup
  if @system_id
    old_id=@system_id
    response = Net::HTTP.get_response(URI.parse("http://#{$server}/#{$reports_controller}s/xml_system_show?id=#{old_id}"))
    system_f=File.open('/var/lib/freegeek-extras/printme/system.xml', 'w')
    system_f.puts(response.body)
    system_f.close
    system_f=File.open('/var/lib/freegeek-extras/printme/system.xml', 'r')
    message "Downloading old information."
    response_xml = XmlSimple.xml_in(response.body)
    if response_xml["error"]
      system_f.close
      system('rm /var/lib/freegeek-extras/printme/system.xml')
      return false
    end
    @system_id=XmlSimple.xml_in(system_f)["id"][0]["content"].to_i
    list_of_reports = []
    XmlSimple.xml_in(Net::HTTP.get_response(URI.parse("http://#{$server}/#{$reports_controller}s/xml_list_for_system?id=#{@system_id}")).body)[$reports_controller.gsub(/_/, '-')].each { |x| list_of_reports << x["id"][0]["content"] }
    for report in list_of_reports
      this_report = open("/var/lib/freegeek-extras/printme/#{$reports_controller}.#{report}.xml", 'w')
      this_report.write(Net::HTTP.get_response(URI.parse("http://#{$server}/#{$reports_controller}s/xml_show/#{report}")).body)
      this_report.close
      message "."
    end
    message "Done!\n\n"
  else
    return false
  end
end

def get_id_and_stuff
  if ! File.exist?('/var/lib/freegeek-extras/')
    system 'sudo mkdir /var/lib/freegeek-extras/'
  end
  system "sudo chown -R #{ENV['USER']}:#{ENV['USER']} /var/lib/freegeek-extras/"
  if ! File.exist?('/var/lib/freegeek-extras/printme')
    mkdir('/var/lib/freegeek-extras/printme/')
  end

  if File.exist?('/var/lib/freegeek-extras/printme/system.xml') #new printme has been ran
    system = File.open('/var/lib/freegeek-extras/printme/system.xml', 'r')
    @system_id ||= XmlSimple.xml_in(system)["id"][0]["content"]
  else #the old/no printme has been ran
    if File.exist?('/tmp/lshw.xml') #old printme has been ran
      mv('/tmp/lshw.xml', '/var/lib/freegeek-extras/printme/lshw.xml.old')
    end
  end

  jobs_xml = XmlSimple.xml_in(Net::HTTP.get_response(URI.parse("http://#{$server}/#{$reports_controller}s/#{$jobs_model}s_xml_index")).body)
  types_xml = XmlSimple.xml_in(Net::HTTP.get_response(URI.parse("http://#{$server}/#{$reports_controller}s/#{$types_model}s_xml_index")).body)

  @jobs={}
  @types={}

  jobs_xml[$jobs_model].each { |x| @jobs[x["description"][0]] = x["id"][0]["content"].to_i if x.class == Hash }
  types_xml[$types_model].each { |x| @types[x["description"][0]] = x["id"][0]["content"].to_i if x.class == Hash }

  @jobs_by_name={}
  @types_by_name={}

  jobs_xml[$jobs_model].each { |x| @jobs_by_name[x["name"][0]] = x["description"][0] if x.class == Hash }
  types_xml[$types_model].each { |x| @types_by_name[x["name"][0]] = x["description"][0] if x.class == Hash }

  @jobs_arr = []
  @types_arr = []

  jobs_xml[$jobs_model].each { |x| @jobs_arr[x["id"][0]["content"].to_i] = x["description"][0] if x.class == Hash }
  types_xml[$types_model].each { |x| @types_arr[x["id"][0]["content"].to_i] = x["description"][0] if x.class == Hash }

  @system_id ||= prompt('If the system had an id on it already, enter that here',
                        'Please supply a number or nothing at all') {|num| num.empty? or (num.to_i.to_s == num)}
  system.close if system
end

#these two are stolen and modified from rubytui

def my__displayMenu( head, ques, *m_items )
  header head
  m_items.each_with_index {|item, i|
    if !item.nil?
      highlight "\t%d" % i.to_s
      display ": %s\n" % item
    end
  }
  choice = prompt( ques )
  return choice.empty? ? nil : choice.to_i
end

def my_menuWithDefault( head, ques, default, *m_items )
  choice = my__displayMenu( head, ques + " [#{default}]", *m_items )
  return default unless choice
  valid_choices = []
  m_items.each_with_index{|x,i|
    valid_choices << i if !x.nil?
  }
  until valid_choices.include?( choice )
    errorMessage "\nPlease enter a valid choice\n\n"
    choice = my__displayMenu( head, ques + " [#{default}]", *m_items )
    return default unless choice
  end
  return m_items[choice]
end

def ask_and_send_stuff
  job = my_menuWithDefault('Work Tasks', 'Which job did you perform?', @jobs_by_name["checker"], *@jobs_arr)
  type = my_menuWithDefault('System Type', 'What kind of system is this intended to be?', @types_by_name['regular'], *@types_arr)
  uid = prompt('What is your volunteer id?', 'Please enter a number.') {|num| num.to_i.to_s == num}
  notes = prompt('What, if anything, is notable about this system?')

  lshw = File.open($lshwname, "rb")
  codename = `lsb_release --description --short`
  data = {
    "contact_id" => uid,
    "#{$jobs_model}_id" => @jobs[job],
    "#{$types_model}_id" => @types[type],
    "system_id" => @system_id,
    "notes" => notes,
    "my_file" => lshw,
    "os" => codename
  }

  url = "http://#{$server}/#{$reports_controller}s/xml_create"
  uri = URI.parse(url)

  mp = Multipart::MultipartPost.new
  query, headers = mp.prepare_query(data)
  lshw.close

  response = post_form(uri, query, headers)
  if response == nil
    errorMessage "Problem posting to the server\n\n"
    exit 1
  end
  response_xml = XmlSimple.xml_in(response.body)
  if response_xml["error"]
    errorMessage "The server return this error: " + response_xml["error"][0] + "\n\n"
    exit 1
  end
  @report_id=response_xml["id"][0]["content"]
  system_id=response_xml["system-id"][0]["content"]
  if system_id != @system_id
    @system_id = system_id
    do_setup
  end
  printme = "/var/lib/freegeek-extras/printme/report.#{@report_id}.xml"
  f = open(printme,'w')
  f.write(response.body)
  f.close()

  if !File.exist?("/var/lib/freegeek-extras/printme/system.xml")
    do_setup
  end

  response = Net::HTTP.get_response(URI.parse("http://#{$server}/#{$reports_controller}s/xml_system_show/#{@system_id}"))
  system=File.open('/var/lib/freegeek-extras/printme/system.xml', 'w')
  response_xml = XmlSimple.xml_in(response.body)
  if response_xml["error"]
    errorMessage "The server return this error: " + response_xml["error"][0] + "\n\n"
    exit 1
  end
  system.puts(response.body)
  system.close
end

class String
  def to_bool
    return true if self == "true"
    return false if self.nil? || self == "false"
    return nil
  end
end

def check_version
  retval = system("ping -c 1 #{$server.gsub(/:.*$/, '')} 1>&2 >/dev/null")
  if retval != true
    errorMessage "I could not connect to the server.\nMake sure you are connected to the network and try again.\n\n"
    exit retval
  end
  response = Net::HTTP.get_response(URI.parse("http://#{$server}/#{$reports_controller}s/check_compat?version=#{$PRINTME_VERSION}"))
  compat = false
  who_knows = false
  begin
    xml = XmlSimple.xml_in(response.body)
    compat = xml["compat"][0]["content"].to_bool
  rescue
    errorMessage "The server returned an invalid response. Seek expert attention." + "\n\n"
    exit 1
  end
  begin
    who_knows = xml["who-knows"][0]["content"].to_bool
  rescue
    errorMessage "The server is incompatible. exiting." + "\n\n"
    exit 1
  end
  if !compat
    errorMessage xml["message"][0] + "\n\n"
    exit 1
  end
  if !who_knows
    errorMessage xml["message"][0] + "\n\n"
    exit 1
  end
end

def main
  check_version
  get_id_and_stuff
  run_lshw_and_test_stuff
  ask_and_send_stuff
  url="http://#{$server}/#{$reports_controller}s/show/#{@report_id}"
  if ! system "firefox #{url}"
    puts url
  end
end

def check_for_people_who_dont_read_the_instructions
  if ENV['USER'] == "root"
    puts "DO NOT RUN PRINTME AS ROOT. if you are typing 'sudo printme', then that is incorrect. Just type 'printme'."
    exit 1
  end
end

check_for_people_who_dont_read_the_instructions
main
