#!/usr/bin/ruby

require 'net/http'
require 'cgi'
require 'uri'
require 'rubytui'
require 'fileutils'
include FileUtils
include RubyTUI

server="bullwinkle.fglan"

module Multipart
  # From: http://kfahlgren.com/code/multipart.rb
  class Param
    attr_accessor :k, :v
    def initialize( k, v )
      @k = k
      @v = v
    end

    def to_multipart
      return "Content-Disposition: form-data; name=\"#{CGI::escape k}\"\r\n\r\n#{v}\r\n"
    end
  end
  class FileParam
    attr_accessor :k, :filename, :content
    def initialize( k, filename, content )
      @k = k
      @filename = filename
      @content = content
    end

    def to_multipart
      # Don't escape mine
      return "Content-Disposition: form-data; name=\"#{k}\"; filename=\"#{filename}\"\r\n" + "Content-Transfer-Encoding: binary\r\n" + "Content-Type: application/xml\r\n\r\n" + content + "\r\n"
    end
  end
  class MultipartPost
    BOUNDARY = 'tarsiers-rule0000'
    HEADER = {"Content-type" => "multipart/form-data, boundary=" + BOUNDARY + " "}

    def prepare_query (params)
      fp = []
      params.each {|k,v|
        if v.respond_to?(:read)
          fp.push(FileParam.new(k, v.path, v.read))
        else
          fp.push(Param.new(k,v))
        end
      }
      query = fp.collect {|p| "--" + BOUNDARY + "\r\n" + p.to_multipart }.join("") + "--" + BOUNDARY + "--"
      return query, HEADER
    end
  end  
end

TIMEOUT_SECONDS = 30
def post_form(url, query, headers)
  Net::HTTP.start(url.host, url.port) { |con|
    con.read_timeout = TIMEOUT_SECONDS
    begin
      return con.post(url.path, query, headers)
    rescue => e
      puts "POSTING Failed #{ e}... #{Time.now}"
    end
  }
end

jobs = {
  "Build" => 1,
  "Quality Control" => 2,
  "Tech Support" => 3,
  "Instructor" => 4,
#  "Special" => 5
}
types = {
  "Low End" => 1,
  "Freekbox" => 2,
  "Grantbox" => 3,
  "Laptop" => 4,
  "High End" => 5,
  "Infrastructure" => 6,
  "Server" => 7,
  "Apple" => 8,
  "Special" => 9
}

retval = system("ping -c 1 " + server + " 1>&2 >/dev/null")

if retval != true
errorMessage "I could not connect to the server.\nMake sure you are connected to the network and try again.\n\n"
exit retval
end

job = menuWithDefault('Work Tasks', 'Which job did you perform?', "Quality Control", *jobs.keys)
type = menuWithDefault('System Type', 'What kind of system is this intended to be?', 'Low End', *types.keys)
uid = prompt('What is your volunteer id?', 'Please enter a number.') {|num| num.to_i.to_s == num}
old_id = prompt('If the system had an id on it already, enter that here',
                'Please supply a number or nothing at all') {|num| num.empty? or (num.to_i.to_s == num)}
notes = prompt('What, if anything, is notable about this system?')
message('Please ensure the printer is connected and press enter')
waitasec

lshwname = '/tmp/lshw.xml'

`sudo lshw -xml>#{lshwname}`

retval = system("xmlstarlet val " + lshwname + " >& /dev/null")

if retval != true
system("tr -d \'\\0\\377\' < " + lshwname + " > " + lshwname + ".clean")
mv(lshwname + ".clean", lshwname)
end

lshw = File.open(lshwname, "rb")

codename = `lsb_release -cs`

data = {
  "technician" => uid,
  "job" => jobs[job],
  "system_type" => types[type],
  "old_id" => old_id,
  "notes" => notes,
  "xmlfile" => lshw,
  "os" => codename
}
url = "http://" + server + "/fgss/fgss.php"
uri = URI.parse(url)

mp = Multipart::MultipartPost.new
query, headers = mp.prepare_query(data)
lshw.close

response = post_form(uri, query, headers)
printme = '/tmp/printthis.html'

#f = open('|html2ps |lpr','w') #:MC: no css styling...
f = open(printme,'w')
f.write(response.body)
f.close()

echo 'print the web browser window/tab that opens...'
system("firefox file://#{printme}")
echo 'go pick up your paper'
